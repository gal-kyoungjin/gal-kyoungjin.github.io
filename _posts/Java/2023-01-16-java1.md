---
layout: single
title:  "[Java] 객체지향 프로그래밍 1"
categories: Java
tag: [Java]
toc: true
author_profile: false
---

# 6-01 객체지향 언어 장점

코드의 재사용성이 높고 유지보수가 용이하다.  
재사용성, 유지보수, 중복된 코드의 제거 -> 3가지 관점에서 공부  


***

# 6-02 클래스와 객체

클래스 정의 : 객체를 정의해 높은 것.  
객체 정의 : 실제로 존재하는 것. 사물 또는 개념.  
  
ex)  
TV 설계도 - 클래스  
TV라는 제품 - 객체  

***

# 6-03 객체의 구성요소 - 속성과 기능

객체의 속성 - 멤버변수(variable)  
객체의 기능 - 메서드(method)  

```java
class Tv {
  String color; // 색깔
  boolean power; // 전원상태
  int channel; // 채널
  
  void power() { power = !power; }
  void channelUp() { channel++; }
  void channelDown() { channel--; }
}
```
  
***

# 6-04 객체와 인스턴스

인스턴스 : 클래스로부터 만들어진 객체  
  
ex)  
책상은 객체다.  
책상은 책상 클래스의 인스턴스다.  

***

# 6-05 한 파일에 여러 클래스 작성하기

올바른 작성 예  
```java
// Hello2.java
public class Hello2 { }
       class Hello3 { }
```
```java
// Hello2.java
class Hello2 { }
class Hello3 { }
```

잘못된 작성 예
```java
// Hello2.java
public class Hello2 { }
public class Hello3 { }
```
```java
// Hello3.java
public class Hello2 { }
       class Hello3 { }
```
```java
// hello2.java
public class Hello2 { }
       class Hello3 { }
```

***

# 6-06 객체의 생성과 사용

클래스명 변수명 = new 클래스명();  

예제 6-1)  
```java
class Ex6_1 {
	public static void main(String argsp[]) {
		Tv t; // Tv 인스턴스를 참조하기 위한 변수 t 선언 
		t = new Tv(); // Tv 인스턴스를 생성한다.
		t.channel = 7; // Tv 인스턴스의 멤버변수 channel
		System.out.println("현재 채널은 " + t.channel + " 입니다.");
		t.channelDown(); // Tv 인스턴스의 메서드 channelDown
		System.out.println("채널 다운");
		System.out.println("현재 채널은 " + t.channel + " 입니다.");
	}
}

class Tv {
	// Tv 속성 (멤버변수)
	String color;
	boolean power;
	int channel;
	
	// Tv 기능 (메서드)
	void power() { power = !power; }
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}
```

***

# 6-07 객체의 생성과 사용 예제

예제 6-2)  
```java
class Ex6_2 {
	public static void main(String[] args) {
		Tv t1 = new Tv();
		Tv t2 = new Tv();
		System.out.println("t1 채널값은 " + t1.channel);
		System.out.println("t2 채널값은 " + t2.channel);
		
		t1.channel = 7;
		System.out.println("t1 채널값을 7로 변경하였습니다.");
	}
}
```

***

# 6-08 객체배열

```java
Tv[] tvArr = new Tv[3]; // 참조변수 객체배열을 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

***

# 6-09 클래스의 정의(1) - 데이터와 함수의 결합

변수 -> 배열 -> 구조체 -> 클래스  
  
변수 : 하나의 데이터를 저장할 수 있는 공간  
배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간  
구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간  
클래스 : 데이터와 함수의 결합(구조체 + 함수)

***

# 6-10 클래스의 정의(2) - 사용자 정의 타입

비객체지향적 코드  
```java
int hour1, hour2, hour3;
int minute1, minute2, minute3;
float second1, second2, second3;
```
```java
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];
```
객체지향적 코드  
```java
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();
```
```java
Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();
```

***

# 6-11 선언위치에 따른 변수의 종류

```java
class Variables { // 클래스 영역
  int iv; // 인스턴스 변수
  static int cv;  // 클래스 변수(static변수, 공유변수)
  
  void method() { // 메서드 영역
    int lv = 0; // 지역변수
  }
}
```

***

# 6-12 클래스 변수와 인스턴스 변수

```java
class Card {
  String kind;  // 인스턴스 변수(개별 속성)
  int number; // 인스턴스 변수(개별 속성)
  
  static int width = 100; // 클래스 변수(공통 속성)
  static int height = 250;  // 클래스 변수(공통 속성)
}
```
***

# 6-13 클래스 변수와 인스턴스 변수 예제

```java
class Ex6_3 {
	public static void main(String args[]) { // 클래스 변수(static 변수)는 객체생성 없이 '클래스이름.클래스 변수'로 직접 사용 가능하다.
		System.out.println("Card.width = " + Card.width);
		System.out.println("Card.height = " + Card.height);
    
		Card c1 = new Card();
		c1.kind = "Heart";
		c1.number = 7;

		Card c2 = new Card();
		c2.kind = "Spade";
		c2.number = 4;

		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2는 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");
		System.out.println("c1의 width와 height를 각각 50, 80으로 변경합니다.");
		c1.width = 50;
		c1.height = 80;

		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2는 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");
	}
}

class Card {
	String kind;
	int number;
	static int width = 100;
	static int height = 250;
}
```

***

# 6-14 메서드란?

특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것

***

# 6-15 메서드의 선언부

```java
int add(int x, int y) {
  int result = x + y;
  
  return result;
}
```
반환값이 없는 경우 'void'

***

# 6-16 메서드의 구현부

지역변수(local variable)는 서로 다른 메서드에서 선언 가능해도 된다.
```java
int add(int x, int y) {
  int result = x + y;
  
  return result;
}

int multiply(int x, int y) {
  int result = x * y;
  
  return result;
}
```

***

# 6-17 메서드의 호출

```java
public static void main(String[] args) {
  int result = add(3, 5); // 메서드를 호출
}
```

***

# 6-18 메서드의 실행 흐름

```java
MyMath mm = new MyMath(); // 먼저 인스턴스를 생성한다.
long value = mm.add(1, 2); // 메서드를 호출한다.

// 메서드 add의 괄호{}안에 있는 문장들이 순서대로 수행
// return문을 만나면, main 메서드로 되돌아와서 이후의 문장들을 실행한다.
```

***

# 6-19 메서드의 실행 흐름 예제

```java
class Ex6_4 {
	public static void main(String args[]) {
		MyMath mm = new MyMath();
		long result1 = mm.add(5L, 3L);
		long result2 = mm.subtract(5L, 3L);
		long result3 = mm.multiply(5L, 3L);
		double result4 = mm.divide(5L, 3L);

		System.out.println("add(5L, 3L) = " + result1);
		System.out.println("subtract(5L, 3L) = " + result2);
		System.out.println("multiply(5L, 3L) = " + result3);
		System.out.println("divide(5L, 3L) = " + result4);
	}
 }

 class MyMath {
	long add(long a, long b) {
		long result = a + b;
		return result;
	}
	long subtract(long a, long b) { return a - b; }
	long multiply(long a, long b) { return a * b; }
	double divide(double a, double b) {
		return a / b;
	}
 }
```

***

# 6-20 return문

void -> return 생략가능. 컴파일러가 자동추가.
int -> return 생략불가.
